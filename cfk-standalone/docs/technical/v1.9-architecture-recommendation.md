# v1.9 Modern Architecture Recommendation

**Date:** November 6, 2025
**Context:** v1.8.1 is cleanup/preparation, v1.9 will be first full OOP/modern architecture release
**Current Branch:** v1.8.1-cleanup
**Decision:** Modernization is happening, question is HOW

---

## Executive Summary

**REVISED RECOMMENDATION: Adopt Slim Framework + Symfony Components**

Given that v1.9 is **planned** as a modern architecture release, the question isn't "should we modernize?" but rather "which approach avoids the 2024 mistakes and sets us up for success?"

**Key Recommendation:**
- Use **Slim Framework** for routing and middleware (lightweight)
- Use **Symfony DI Container** for dependency injection (best-in-class)
- Migrate **incrementally** (avoid parallel systems)
- Keep **single entry point** throughout migration
- Refactor **one feature at a time** (learn as you go)

---

## Critical Learning from 2024 PSR-4 Attempt

### What Went Wrong in 2024

❌ **Built complete parallel system**
- Two entry points: `public/index.php` (new) vs `index.php` (old)
- Two architectures running side-by-side
- Never migrated existing features
- Never cut over to new system

❌ **All-or-nothing approach**
- Built entire infrastructure first
- Built 2,556 lines before using any of it
- Overwhelmed by scope
- Abandoned in favor of "just ship it"

❌ **No incremental value**
- Couldn't use new code until 100% complete
- Old system kept winning because it worked
- New system never proved its worth

### What v1.9 Must Do Differently

✅ **Single system, gradual migration**
- One entry point throughout
- Migrate one page/feature at a time
- New and old code coexist during transition
- Always have working application

✅ **Incremental approach**
- Add framework infrastructure (Week 1)
- Migrate smallest feature (Week 2)
- Prove value immediately
- Continue feature-by-feature

✅ **Demonstrate value early**
- First migrated feature shows benefits
- Team learns patterns on real code
- Momentum builds with each migration
- Clear progress markers

---

## Recommended Architecture for v1.9

### Framework Choice: Slim + Symfony Components

**Why This Combination?**

**Slim Framework** provides:
- ✅ Lightweight routing (PSR-7)
- ✅ Middleware pipeline
- ✅ Request/Response handling
- ✅ Minimal overhead (~1MB)
- ✅ Easy to learn
- ✅ Not opinionated (flexible)

**Symfony Components** provide:
- ✅ Best DI container in PHP
- ✅ Use only what you need
- ✅ Battle-tested (powers Drupal, Laravel)
- ✅ Excellent documentation
- ✅ Can add more components later

**Existing CFK\* Classes** provide:
- ✅ Your domain logic (keep it!)
- ✅ Database operations (Connection class)
- ✅ Business rules (Manager classes)
- ✅ Already namespaced and typed

### Target Architecture for v1.9

```
v1.9 Architecture:
┌─────────────────────────────────────────────────────────┐
│ index.php (Single Entry Point)                          │
│ ├── Slim Application                                    │
│ │   ├── Routing (Slim)                                  │
│ │   ├── Middleware (CSRF, Auth, Logging)               │
│ │   └── Dependency Injection (Symfony Container)       │
│ │                                                        │
│ ├── Controllers (New)                                   │
│ │   ├── ChildController                                 │
│ │   ├── SponsorshipController                          │
│ │   └── AdminController                                 │
│ │                                                        │
│ ├── Services (Refactored from Managers)                │
│ │   ├── CFK\Sponsorship\SponsorshipService            │
│ │   ├── CFK\Email\EmailService                        │
│ │   └── CFK\CSV\CsvService                            │
│ │                                                        │
│ ├── Repositories (New - Data Access)                   │
│ │   ├── CFK\Repository\ChildRepository                │
│ │   ├── CFK\Repository\SponsorshipRepository         │
│ │   └── CFK\Repository\FamilyRepository              │
│ │                                                        │
│ ├── Database (Existing - Keep as-is)                   │
│ │   └── CFK\Database\Connection                        │
│ │                                                        │
│ └── Templates (Twig or Plates)                         │
│     ├── children/list.twig                             │
│     ├── children/detail.twig                           │
│     └── admin/dashboard.twig                           │
└─────────────────────────────────────────────────────────┘

URL Structure:
Before (v1.8): ?page=children&filter=available
After (v1.9):  /children?filter=available

Before (v1.8): ?page=child&id=123
After (v1.9):  /children/123

Before (v1.8): ?page=admin&action=manage_children
After (v1.9):  /admin/children
```

---

## Why NOT Full Laravel or Symfony?

### Why Not Laravel?

While Laravel is excellent, it's **too opinionated** for this migration:

❌ **Forces complete rewrite**
- Must use Eloquent ORM (can't keep your Connection class easily)
- Must follow Laravel directory structure
- Must adopt Laravel conventions everywhere
- All-or-nothing migration

❌ **Overkill for this scale**
- Includes queues, broadcasting, events (won't use)
- Large framework overhead
- Many features you don't need

❌ **Harder to migrate incrementally**
- Wants to control everything
- Difficult to mix old and new code
- Framework "magic" can be confusing

✅ **When to use Laravel instead:**
- If you're willing to do complete rewrite
- If team wants "batteries included"
- If you'll use most Laravel features
- If rapid development is priority after migration

### Why Not Full Symfony?

Symfony is enterprise-grade but **too complex** for initial migration:

❌ **Steep learning curve**
- Bundles, services, configurations
- Many concepts to learn at once
- Overwhelming for first framework adoption

❌ **Heavy initial setup**
- Lots of configuration
- Many decisions to make
- Can be analysis paralysis

❌ **Over-engineered for current scale**
- Built for applications with 100+ developers
- Your team is 1-2 people
- Complexity outweighs benefits at this scale

✅ **When to use Symfony instead:**
- If building enterprise application (50K+ lines)
- If team has strong Symfony experience
- If you need maximum flexibility
- If you're planning massive scale

### Why Slim + Symfony Components Is Perfect

✅ **Start small, grow as needed**
- Add only what you need today
- Can add more Symfony components later
- Can even migrate to full Symfony if needed

✅ **Incremental learning curve**
- Learn routing first (Slim)
- Then learn DI (Symfony Container)
- Then add services gradually
- Step-by-step complexity

✅ **Keep existing code working**
- Your CFK\* classes stay mostly as-is
- Just inject them instead of static calls
- Gradually refactor over time

✅ **Minimal vendor lock-in**
- PSR-7 (standard interfaces)
- Can swap routing later if needed
- Own your architecture

---

## Migration Strategy for v1.9

### Phase 1: Infrastructure Setup (Week 1)

**Goal:** Add framework without breaking existing code

**Tasks:**
1. Install dependencies
   ```bash
   composer require slim/slim slim/psr7
   composer require symfony/dependency-injection
   composer require symfony/config
   composer require twig/twig  # Template engine
   ```

2. Create new `public/index.php` entry point
   - Slim application setup
   - Configure DI container
   - Add routes (initially empty)
   - Keep old `index.php` as fallback

3. Configure dependency injection
   ```php
   // config/services.php
   use CFK\Database\Connection;
   use Symfony\Component\DependencyInjection\ContainerBuilder;

   $container = new ContainerBuilder();

   // Register your existing classes
   $container->register('db.connection', Connection::class);
   $container->register('sponsorship.manager', SponsorshipManager::class)
       ->addArgument(new Reference('db.connection'));

   return $container;
   ```

4. Set up basic routing
   ```php
   // config/routes.php
   use Slim\App;

   return function (App $app) {
       // Home
       $app->get('/', HomeController::class);

       // Children
       $app->get('/children', ChildrenController::class . ':list');
       $app->get('/children/{id}', ChildrenController::class . ':show');

       // Legacy fallback (during migration)
       $app->get('/legacy/{page}', LegacyController::class);
   };
   ```

**Deliverable:** Working Slim app that can coexist with old system

---

### Phase 2: Migrate First Feature (Week 2)

**Goal:** Prove the architecture with one complete feature

**Choose Simplest Feature:** View child profile (`/children/123`)

**Why start here:**
- Read-only (no complex validation)
- Single database query
- Simple template
- Low risk

**Migration Steps:**

1. Create ChildController
   ```php
   namespace CFK\Controller;

   use CFK\Repository\ChildRepository;
   use Psr\Http\Message\ResponseInterface as Response;
   use Psr\Http\Message\ServerRequestInterface as Request;
   use Slim\Views\Twig;

   class ChildController
   {
       public function __construct(
           private ChildRepository $childRepo,
           private Twig $view
       ) {}

       public function show(Request $request, Response $response, array $args): Response
       {
           $childId = (int) $args['id'];
           $child = $this->childRepo->findById($childId);

           if (!$child) {
               return $response->withStatus(404);
           }

           return $this->view->render($response, 'children/show.twig', [
               'child' => $child
           ]);
       }
   }
   ```

2. Create ChildRepository (data access)
   ```php
   namespace CFK\Repository;

   use CFK\Database\Connection;

   class ChildRepository
   {
       public function __construct(
           private Connection $db
       ) {}

       public function findById(int $id): ?array
       {
           return $this->db->fetchRow(
               "SELECT c.*, f.family_number
                FROM children c
                JOIN families f ON c.family_id = f.id
                WHERE c.id = ?",
               [$id]
           );
       }
   }
   ```

3. Create Twig template
   ```twig
   {# templates/children/show.twig #}
   {% extends "layout.twig" %}

   {% block content %}
       <h1>{{ child.first_name }} {{ child.last_name }}</h1>
       <p>Age: {{ child.age_years }} years</p>
       {# etc #}
   {% endblock %}
   ```

4. Add route
   ```php
   $app->get('/children/{id:\d+}', ChildController::class . ':show');
   ```

5. Test thoroughly
   - Manual testing
   - Compare output with old system
   - Check edge cases (404, invalid ID, etc.)

**Deliverable:** First feature fully migrated, working in production alongside old code

**Success Criteria:**
- ✅ URL works: `/children/123`
- ✅ Old URL still works: `?page=child&id=123` (legacy route)
- ✅ Identical output to old system
- ✅ Team understands the pattern

---

### Phase 3: Incremental Migration (Weeks 3-8)

**Goal:** Migrate remaining features one at a time

**Migration Order (by complexity):**

**Week 3: Read-Only Pages**
- Children list (`/children`)
- Admin dashboard (`/admin`)
- Reports (`/admin/reports`)

**Week 4: Simple Forms**
- Contact forms
- Email lookups
- Simple searches

**Week 5: Complex Workflows**
- Child selection/cart
- Reservation system
- Sponsorship confirmation

**Week 6: Admin CRUD**
- Manage children
- Manage sponsorships
- CSV import

**Week 7: Authentication & Authorization**
- Magic link system
- Admin authentication
- Session handling

**Week 8: Testing & Cleanup**
- Write unit tests
- Remove old code
- Update documentation

**For Each Feature:**
1. Create controller
2. Create/refactor repository
3. Create/refactor service (if needed)
4. Create template
5. Add route
6. Test thoroughly
7. Keep legacy route as fallback initially
8. Remove legacy code only after confidence

---

### Phase 4: Service Layer Refactoring (Weeks 9-10)

**Goal:** Refactor Manager classes into proper service layer

**Current State:**
```php
// CFK\Sponsorship\Manager - does everything
class Manager {
    public static function reserveChild($id) {
        // Business logic + database access mixed
    }
}
```

**Target State:**
```php
// CFK\Service\SponsorshipService - business logic only
class SponsorshipService {
    public function __construct(
        private SponsorshipRepository $repo,
        private EmailService $email,
        private LoggerInterface $logger
    ) {}

    public function reserveChild(int $childId, string $sponsorEmail): Result {
        // Only business logic
        // Dependencies injected
        // Returns value objects
    }
}

// CFK\Repository\SponsorshipRepository - data access only
class SponsorshipRepository {
    public function __construct(
        private Connection $db
    ) {}

    public function findAvailableChild(int $id): ?array {
        // Only database operations
    }
}
```

**Refactor in this order:**
1. Sponsorship (most complex)
2. Email
3. CSV
4. Archive
5. Avatar
6. Backup
7. Report

---

### Phase 5: Testing Infrastructure (Weeks 11-12)

**Goal:** Add comprehensive test suite

Now that you have DI, testing becomes possible:

```php
// tests/Unit/Service/SponsorshipServiceTest.php
use PHPUnit\Framework\TestCase;

class SponsorshipServiceTest extends TestCase
{
    public function testReserveAvailableChild(): void
    {
        // Mock repository
        $repo = $this->createMock(SponsorshipRepository::class);
        $repo->method('findAvailableChild')
             ->willReturn(['id' => 123, 'status' => 'available']);

        // Inject mock
        $service = new SponsorshipService($repo, $emailMock, $loggerMock);

        // Test business logic
        $result = $service->reserveChild(123, 'sponsor@example.com');

        $this->assertTrue($result->isSuccess());
    }
}
```

**Test Coverage Goals:**
- Unit tests for all services (80%+ coverage)
- Integration tests for repositories
- Functional tests for critical workflows
- Keep existing security-functional-tests.sh

---

## Technical Decisions for v1.9

### 1. Routing: Slim Framework

**Choice:** Slim 4.x (PSR-7, PSR-15)

**Configuration:**
```php
// public/index.php
use Slim\Factory\AppFactory;
use DI\Container;

require __DIR__ . '/../vendor/autoload.php';

// Load environment
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->load();

// Create DI container
$container = require __DIR__ . '/../config/container.php';
AppFactory::setContainer($container);

// Create Slim app
$app = AppFactory::create();

// Add middleware
$app->addRoutingMiddleware();
$app->addErrorMiddleware(true, true, true);

// Register routes
$routes = require __DIR__ . '/../config/routes.php';
$routes($app);

// Run
$app->run();
```

**Benefits:**
- Clean URLs (`/children/123`)
- PSR-7 request/response
- Middleware support
- Route parameters
- Minimal overhead

---

### 2. Dependency Injection: Symfony DI Container

**Choice:** `symfony/dependency-injection` + `symfony/config`

**Configuration:**
```php
// config/container.php
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

// Database
$container->register('db.connection', CFK\Database\Connection::class)
    ->setPublic(true);

// Repositories
$container->register('repository.child', CFK\Repository\ChildRepository::class)
    ->addArgument(new Reference('db.connection'))
    ->setPublic(true);

$container->register('repository.sponsorship', CFK\Repository\SponsorshipRepository::class)
    ->addArgument(new Reference('db.connection'))
    ->setPublic(true);

// Services
$container->register('service.sponsorship', CFK\Service\SponsorshipService::class)
    ->addArgument(new Reference('repository.sponsorship'))
    ->addArgument(new Reference('service.email'))
    ->addArgument(new Reference('logger'))
    ->setPublic(true);

$container->register('service.email', CFK\Email\Manager::class)
    ->setPublic(true);

// Controllers
$container->register(CFK\Controller\ChildController::class)
    ->addArgument(new Reference('repository.child'))
    ->addArgument(new Reference('twig'))
    ->setPublic(true);

// Template engine
$container->register('twig', Twig::class)
    ->setFactory([Twig::class, 'create'])
    ->addArgument(__DIR__ . '/../templates')
    ->setPublic(true);

$container->compile();

return $container;
```

**Benefits:**
- Best DI container in PHP
- Autowiring possible
- Service configuration
- Can cache compiled container
- Industry standard

---

### 3. Templates: Twig

**Choice:** Twig 3.x

**Why Twig over PHP templates:**
- ✅ Auto-escaping (XSS prevention)
- ✅ Template inheritance
- ✅ Clean syntax
- ✅ No PHP logic in templates
- ✅ Easy for designers

**Example:**
```twig
{# templates/layout.twig #}
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}CFK Sponsorship{% endblock %}</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
</head>
<body>
    {% include 'partials/header.twig' %}

    <main>
        {% block content %}{% endblock %}
    </main>

    {% include 'partials/footer.twig' %}
</body>
</html>
```

```twig
{# templates/children/show.twig #}
{% extends 'layout.twig' %}

{% block title %}{{ child.first_name }} - CFK Sponsorship{% endblock %}

{% block content %}
    <div class="child-profile">
        <img src="{{ child.avatar_url }}" alt="Avatar">
        <h1>Child {{ child.display_id }}</h1>
        <p>Age: {{ child.age_years }} years, {{ child.age_months }} months</p>
        <p>Grade: {{ child.grade_level }}</p>

        {% if child.status == 'available' %}
            <form method="post" action="/cart/add">
                <input type="hidden" name="child_id" value="{{ child.id }}">
                <button type="submit">Select for Sponsorship</button>
            </form>
        {% else %}
            <p class="unavailable">This child has been sponsored.</p>
        {% endif %}
    </div>
{% endblock %}
```

---

### 4. Database: Keep CFK\Database\Connection

**Decision:** Keep your existing Connection class

**Why:**
- ✅ Already works well
- ✅ PDO-based (secure)
- ✅ Simple and clear
- ✅ No need to learn ORM
- ✅ Avoid over-engineering

**Just add interface:**
```php
namespace CFK\Database;

interface ConnectionInterface
{
    public static function fetchAll(string $sql, array $params = []): array;
    public static function fetchRow(string $sql, array $params = []): ?array;
    public static function execute(string $sql, array $params = []): int;
    public static function insert(string $table, array $data): int;
    public static function update(string $table, array $data, array $where): int;
}

class Connection implements ConnectionInterface
{
    // Existing code stays the same
}
```

**Later (optional):** Could add Doctrine DBAL if needed, but not required.

---

### 5. Validation: Symfony Validator (Later)

**For v1.9:** Keep simple manual validation

**For v2.0:** Consider adding:
```bash
composer require symfony/validator
```

```php
use Symfony\Component\Validator\Constraints as Assert;

class SponsorshipRequest
{
    #[Assert\NotBlank]
    #[Assert\Email]
    public string $email;

    #[Assert\NotBlank]
    #[Assert\Length(min: 2, max: 50)]
    public string $firstName;

    #[Assert\Positive]
    public int $childId;
}
```

---

## Directory Structure for v1.9

```
cfk-standalone/
├── public/
│   ├── index.php              ← NEW: Slim entry point
│   ├── assets/                ← Keep as-is
│   └── .htaccess              ← NEW: Rewrite rules
│
├── src/
│   ├── Controller/            ← NEW
│   │   ├── Admin/
│   │   │   ├── ChildrenController.php
│   │   │   ├── SponsorshipsController.php
│   │   │   └── ReportsController.php
│   │   ├── ChildrenController.php
│   │   ├── SponsorshipController.php
│   │   ├── CartController.php
│   │   └── HomeController.php
│   │
│   ├── Service/               ← NEW (refactored from Managers)
│   │   ├── SponsorshipService.php
│   │   ├── EmailService.php
│   │   ├── CsvService.php
│   │   └── ArchiveService.php
│   │
│   ├── Repository/            ← NEW (data access layer)
│   │   ├── ChildRepository.php
│   │   ├── SponsorshipRepository.php
│   │   ├── FamilyRepository.php
│   │   └── AdminRepository.php
│   │
│   ├── Database/              ← KEEP (existing)
│   │   └── Connection.php
│   │
│   ├── Email/                 ← KEEP (existing)
│   │   └── Manager.php
│   │
│   ├── CSV/                   ← KEEP (existing)
│   │   └── Handler.php
│   │
│   └── [Other existing components]
│
├── templates/                 ← NEW (Twig templates)
│   ├── layout.twig
│   ├── partials/
│   │   ├── header.twig
│   │   ├── footer.twig
│   │   └── navigation.twig
│   ├── children/
│   │   ├── list.twig
│   │   └── show.twig
│   ├── sponsorship/
│   │   ├── cart.twig
│   │   └── confirmation.twig
│   └── admin/
│       ├── dashboard.twig
│       ├── children/
│       └── sponsorships/
│
├── config/
│   ├── container.php          ← NEW (DI configuration)
│   ├── routes.php             ← NEW (Route definitions)
│   ├── config.php             ← KEEP (existing settings)
│   └── database.php           ← KEEP (existing)
│
├── tests/
│   ├── Unit/                  ← NEW
│   │   ├── Service/
│   │   └── Repository/
│   ├── Integration/           ← NEW
│   └── Functional/            ← EXISTING (keep security tests)
│
├── legacy/                    ← OLD CODE (during migration)
│   ├── pages/
│   ├── admin/
│   └── includes/
│   (Delete after migration complete)
│
├── docs/                      ← Enhanced
│   ├── migration/
│   │   ├── v1.9-migration-plan.md
│   │   └── feature-migration-status.md
│   └── [existing docs]
│
├── composer.json              ← Updated dependencies
├── phpunit.xml                ← NEW
└── .htaccess                  ← Updated for Slim routing
```

---

## Migration Checklist

### Pre-Migration (Complete in v1.8.1)

- [x] Remove dead code (3,624 lines deleted)
- [x] Install quality tools (PHPStan, Psalm, etc.)
- [x] Establish baseline metrics
- [x] Document current architecture
- [x] Clean up technical debt

### Week 1: Infrastructure

- [ ] Install Slim + Symfony DI + Twig
- [ ] Create `public/index.php` entry point
- [ ] Configure DI container (`config/container.php`)
- [ ] Set up routing structure (`config/routes.php`)
- [ ] Configure Twig templates
- [ ] Add .htaccess for URL rewriting
- [ ] Test basic "Hello World" route
- [ ] Document new structure

### Week 2: First Feature

- [ ] Create ChildController
- [ ] Create ChildRepository
- [ ] Create child detail template
- [ ] Add route: `/children/{id}`
- [ ] Test thoroughly vs old system
- [ ] Keep legacy route working
- [ ] Deploy to staging
- [ ] Get team feedback

### Weeks 3-8: Feature Migration

**Track progress in:** `docs/migration/feature-migration-status.md`

- [ ] Children list
- [ ] Admin dashboard
- [ ] Reports
- [ ] Contact forms
- [ ] Email lookups
- [ ] Cart/selections
- [ ] Reservation system
- [ ] Sponsorship workflow
- [ ] Manage children
- [ ] Manage sponsorships
- [ ] CSV import
- [ ] Magic link auth
- [ ] Admin auth
- [ ] [etc - full feature list TBD]

### Weeks 9-10: Refactoring

- [ ] Refactor SponsorshipManager → Service + Repository
- [ ] Refactor EmailManager → EmailService
- [ ] Refactor CsvHandler → CsvService
- [ ] Refactor ArchiveManager → ArchiveService
- [ ] Refactor AvatarManager → AvatarService
- [ ] Update all DI configurations
- [ ] Update all tests

### Weeks 11-12: Testing

- [ ] Unit tests for all services
- [ ] Integration tests for repositories
- [ ] Functional tests for workflows
- [ ] Achieve 80%+ code coverage
- [ ] Document testing strategy

### Final: Cleanup & Launch

- [ ] Remove all legacy code
- [ ] Remove legacy routes
- [ ] Update all documentation
- [ ] Performance testing
- [ ] Security audit
- [ ] Deploy v1.9 to production

---

## Success Metrics for v1.9

### Technical Metrics

- ✅ 100% feature parity with v1.8
- ✅ 0% downtime during migration
- ✅ 80%+ unit test coverage
- ✅ Clean URL structure (/children/123)
- ✅ Dependency injection throughout
- ✅ Single entry point (no parallel systems)
- ✅ All PHPStan level 6 errors resolved

### Team Metrics

- ✅ Team understands new architecture
- ✅ Documentation is comprehensive
- ✅ New features easier to add
- ✅ Testing is straightforward
- ✅ Onboarding new devs is faster

### Business Metrics

- ✅ No regression bugs
- ✅ Performance same or better
- ✅ All existing functionality works
- ✅ Users see no difference (transparent migration)

---

## Risks & Mitigations

### Risk 1: Scope Creep

**Risk:** Migration takes longer than estimated

**Mitigation:**
- Strict feature-by-feature migration
- Time-box each feature (max 2-3 days)
- Skip optional improvements during migration
- Can always refactor more in v1.9.1, v1.9.2

### Risk 2: Parallel Systems (2024 Repeat)

**Risk:** End up with two working systems again

**Mitigation:**
- Single entry point from Day 1
- Legacy routes redirect to new system
- Delete old code as soon as new code is proven
- Feature flags for gradual rollout if needed

### Risk 3: Breaking Changes

**Risk:** Migration breaks critical functionality

**Mitigation:**
- Comprehensive testing at each step
- Keep legacy routes as fallback initially
- Deploy to staging first
- Canary deployment (10% users, then 50%, then 100%)
- Easy rollback plan

### Risk 4: Team Overwhelm

**Risk:** New patterns too complex, team struggles

**Mitigation:**
- Start with simplest feature
- Pair programming for first few migrations
- Comprehensive documentation
- Regular retrospectives
- Adjust approach based on feedback

---

## Why This Will Succeed (Unlike 2024)

### 2024 PSR-4 Attempt (Failed)

❌ Built everything before using anything
❌ Two complete parallel systems
❌ Never migrated existing features
❌ All-or-nothing approach
❌ No incremental value

### v1.9 Migration (Will Succeed)

✅ Use infrastructure immediately (Week 2)
✅ Single system, gradual migration
✅ Migrate existing features one by one
✅ Incremental, testable approach
✅ Value delivered at each step

### Key Differences

| Aspect | 2024 Attempt | v1.9 Plan |
|--------|--------------|-----------|
| **Approach** | Big Bang | Incremental |
| **Entry Points** | 2 (old + new) | 1 (unified) |
| **Value** | None until 100% | Immediate |
| **Testing** | End-to-end only | Each feature |
| **Rollback** | Impossible | Easy |
| **Risk** | All at once | Distributed |
| **Team Learning** | Overwhelming | Gradual |

---

## Next Steps

### Immediate (This Week)

1. **Review this plan** with team
2. **Identify any concerns** or questions
3. **Adjust timeline** if needed
4. **Get buy-in** from all stakeholders
5. **Create v1.9 branch** from v1.8.1-cleanup

### Week 1 (Next Week)

1. Install Slim + Symfony DI + Twig
2. Create infrastructure (container, routes, entry point)
3. Test basic routing
4. Document setup for team

### Week 2 (Following Week)

1. Migrate first feature (child detail page)
2. Prove the architecture works
3. Get team comfortable with patterns
4. Adjust approach based on learnings

### Ongoing

1. Weekly team retrospectives
2. Update migration status doc
3. Adjust timeline as needed
4. Celebrate small wins

---

## Conclusion

**Revised Recommendation for v1.9:**

✅ **Adopt Slim Framework + Symfony Components**

This approach:
- ✅ Provides modern architecture you want
- ✅ Avoids 2024 mistakes (incremental, not parallel)
- ✅ Keeps existing code working during migration
- ✅ Allows gradual learning curve
- ✅ Delivers value at each step
- ✅ Minimizes risk
- ✅ Sets up v2.0+ for continued growth

**Timeline:** 12 weeks for complete migration
**Risk:** Medium (mitigated by incremental approach)
**Payoff:** Modern, testable, maintainable architecture

---

**Ready to proceed?** The next step is to review this plan, make any adjustments, and create the v1.9 branch to begin infrastructure setup.

**Questions to answer:**
1. Does 12-week timeline work for your schedule?
2. Any features we should prioritize differently?
3. Any concerns about the technology choices?
4. Team ready for this migration?

---

**Document:** v1.9-architecture-recommendation.md
**Author:** Claude Code
**Date:** November 6, 2025
**Status:** Awaiting approval to proceed
